```{r imports}
#| verbose: False
#| warning: False

library(tidyverse)
library(tidycensus)

library(fpp3)
library(sf)

library(patchwork)
library(knitr)
library(kableExtra)
library(broom)
library(Metrics)
library(lmtest)
library(sandwich)
library(lme4)

acs_5_yearly_data <- readRDS("data/acs_5_yearly_data.rds")
acs_1_yearly_data <- readRDS("data/acs_1_yearly_data.rds")
mapping_yearly_data <- readRDS("data/mapping_yearly_data.rds")
crime_data <- readRDS("data/crime_data_merged.rds")
```

```{r crime_and_pop_mapping}
#| warning: False
  
# Base map for year 2023
data_2023 <- mapping_yearly_data |> 
  filter(year == 2023)

# Compute centroids only for the top cities
city_centroids <- data_2023 |>
  filter(top_cities == 1) |>
  st_centroid()

# Plot A — population
a <- ggplot(data_2023) +
  geom_sf(aes(fill = total_population_acs5), color = "white") +
  # black border for reservations
  geom_sf(
    data = subset(data_2023, reservations == 1),
    fill = NA,
    color = "black",
    size = .75
  ) +
  # Black dot at centroid for top cities
  geom_sf(
    data = city_centroids,
    color = "black", size = 1.8
  ) +
  scale_fill_viridis_c(
    option = "plasma",
    trans = "log10",
    name = "Total Population",
    labels = scales::label_number(scale_cut = scales::cut_short_scale())
  ) +
  theme_minimal() +
  theme(
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    legend.position = "bottom",
    plot.margin = margin(0, 0, 0, 0)
  )

# Plot B — crime rate
b <- ggplot(data_2023) +
  geom_sf(aes(fill = crime_rate), color = "white") +
  geom_sf(
    data = subset(data_2023, reservations == 1),
    fill = NA,
    color = "black",
    size = .75
  ) +
  # Black dot at centroid for top cities
  geom_sf(
    data = city_centroids,
    color = "black", size = 1.8
  ) +
  scale_fill_viridis_c(
    option = "plasma",
    name = "Crime Rates"
  ) +
  theme_minimal() +
  theme(
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    legend.position = "bottom",
    plot.margin = margin(0, 0, 0, 0)
  )

# Combine with patchwork
a + b +
  plot_annotation(
    title = "Overall Population Analysis (2023)",
    subtitle = "Population by County and Yearly Trends",
    caption = "Centroids on counties with the top 5 largest cites and border around counties with reservations
    Source: ACS 5-Year Estimates and FBI Crime data"
    
  )
```

```{r homicides_time_series}
# Monthly totals
monthly_ts <- crime_data |>
  group_by(month) |>
  summarise(homicides = sum(homicides), .groups = "drop") |>
  mutate(type = "Monthly")  # Add type for plotting

# Yearly totals
yearly_ts <- crime_data |>
  group_by(year, county) |>
  summarise(
    population = first(total_population_acs1),  # take one value per county
    homicides = sum(homicides, na.rm = TRUE),
    .groups = "drop"
  ) |>
  group_by(year) |>
  summarise(
    population = sum(population, na.rm = TRUE),  # now only sum once per county
    homicides = sum(homicides, na.rm = TRUE),
    .groups = "drop"
  ) |>
  mutate(
    month = as.Date(paste0(year, "-01-01")),
    type = "Yearly"
  ) |>
  select(month, homicides, population, type)

# plotting df
combined_ts <- bind_rows(monthly_ts, yearly_ts)


# show the reasons for using yearly data due to how monthly is reported
ggplot(combined_ts, aes(x = month, y = homicides, color = type)) +
  geom_line(size = 1) +
  geom_point(data = subset(combined_ts, type == "Yearly"), size = 2) +  # emphasize yearly points
  scale_color_manual(values = c("Monthly" = "steelblue", "Yearly" = "darkblue")) +
  theme_minimal() +
  labs(title = "Minnesota Homicides Over Time", x = "Date", y = "Homicides", color = "Time Period")+
theme(
  legend.position = c(0.1, 0.8),   # normalized coordinates
  legend.background = element_rect(fill = alpha("white", 0.6)), # optional transparent box
  legend.title = element_text("Time Period")
)


# refactor yearly_ts data to only contain acs1 counties to compare homicide rates to population counts
yearly_ts <- acs_1_yearly_data|>
  group_by(year)|>
  summarise(population = sum(total_population_acs1),
            homicides_pc = sum(homicides)/sum(total_population_acs1),
            across(c(arson, assaults, burglary, gta, homicides, larceny, rape, robbery), sum))|>
  mutate(crime_rate = (arson+assaults+burglary+gta+homicides+larceny+rape+robbery)/population)
  


# show homicides vs population relationship
# Compute a scaling factor to map population into homicide scale
scale_factor <- max(yearly_ts$crime_rate, na.rm = TRUE) / max(yearly_ts$population, na.rm = TRUE)

ggplot(yearly_ts, aes(x = year)) +
  # Population line (left axis, true scale)
  geom_line(aes(y = population, color = "Population"), size = 1, linetype = "dashed") +
  geom_point(aes(y = population, color = "Population"), size = 2) +
  
  # Homicides line (right axis, scaled down)
  geom_line(aes(y = crime_rate / scale_factor, color = "General Crime Rate"), size = 1) +
  geom_point(aes(y = crime_rate / scale_factor, color = "General Crime Rate"), size = 2) +
  
  scale_y_continuous(
    name = "Population",
    sec.axis = sec_axis(~ . * scale_factor, name = "General Crime Rate")
  ) +
  scale_color_manual(
    values = c("Population" = "firebrick", "General Crime Rate" = "purple")
  ) +
  theme_minimal() +
  labs(
    title = "Minnesota Population vs Crime Rates Over Time for ACS1 Counties",
    x = "Year",
    color = "",
    caption = "Source: ACS1 estimates; using Decennial counts for 2020"
  )+
theme(
  legend.position = c(0.2, 0.2),   # normalized coordinates
  legend.background = element_rect(fill = alpha("white", 0.6)), # optional transparent box
  legend.title = element_blank()
)


scale_factor <- max(yearly_ts$homicides_pc, na.rm = TRUE) / max(yearly_ts$crime_rate, na.rm = TRUE)

ggplot(yearly_ts, aes(x = year)) +
  # Homicides per capita (true scale, left axis)
  geom_line(aes(y = homicides_pc, color = "Homicides per Capita"), size = 1) +
  geom_point(aes(y = homicides_pc, color = "Homicides per Capita"), size = 2) +
  
  # General crime rate (scaled, right axis)
  geom_line(aes(y = crime_rate * scale_factor, color = "General Crime Rate"), size = 1, linetype = "dashed") +
  geom_point(aes(y = crime_rate * scale_factor, color = "General Crime Rate"), size = 2) +
  
  # Two axes
  scale_y_continuous(
    name = "Homicides per Capita",
    sec.axis = sec_axis(~ . / scale_factor, name = "General Crime Rate")
  ) +
  
  # Colors and labels
  scale_color_manual(
    values = c("Homicides per Capita" = "darkblue", 
               "General Crime Rate" = "purple")
  ) +
  theme_minimal() +
  labs(
    title = "Homicides per Capita vs General Crime Rate (ACS1 Counties)",
    x = "Year",
    color = "",
    caption = "Source: FBI Crime data and ACS1 estimates"
  )



acs_1_yearly_data|>
  ggplot(aes(x = homicides/total_population_acs1))+
  geom_density()+
  theme_minimal()+
  labs(title = "Density of Minnesota Homicides by County by Year", 
       x = "Homicides per Capita per Year", y = NULL, 
       caption = "Source: FBI Crime data, and ACS1 estimates; using Decennial counts for 2020")

acs_1_yearly_data|>
  ggplot(aes(x = crime_rate))+
  geom_density()+
  theme_minimal()+
  labs(title = "Density of Minnesota Crime Rates by County by Year", 
       x = "Crimes per Capita per Year", y = NULL, 
       caption = "Source: FBI Crime data, and ACS1 estimates; using Decennial counts for 2020")
```

```{r acs_1_pre_modeling_comparisons}
### vars to calculate stats across for modeling
modeling_vars <- c(
  "homicide_rate", "crime_rate", "periods", "post_covid", "msp_main_counties",
  "officers", "median_household_income_acs1", "pct_lessthan_5kincome", 
  "pct_highschool_or_greater", "pct_children_missing_parents", 
  "pct_non_white", "Binge.drinking.prevalence", "pct_young_males", 
  "persons_per_household", "persons_per_m2"
)

### Descriptive stats
means <- acs_1_yearly_data |>
  summarise(across(all_of(modeling_vars), ~ mean(.x, na.rm = TRUE)))

sds <- acs_1_yearly_data |>
  summarise(across(all_of(modeling_vars), ~ sd(.x, na.rm = TRUE)))

bind_rows(list(mean = means, sd = sds), .id = "stat")|>
  select(-periods, -post_covid, -msp_main_counties)|>
  pivot_longer(-stat, names_to = "variable", values_to = "value")|>
  pivot_wider(names_from = "stat")

### correlation matrix
# cor is off because of serial and inter county correlation
target <- "homicide_rate"
lapply(setdiff(modeling_vars, target), function(var) {
  test <- cor.test(
    acs_1_yearly_data[[target]],
    acs_1_yearly_data[[var]],
    method = "pearson"
  )
  data.frame(
    variable = var,
    estimate = test$estimate,
    p.value = test$p.value
  )
}) |> bind_rows()
```

```{r acs1_modeling}
# starting mixed effects model with one measure of each social disorganization factor
# random effect by county to allow for different relationships
# simple periods variable to account for time series
model_lag1 <- lmer(crime_rate ~ officers + pct_lessthan_5kincome +
              pct_highschool_or_greater + pct_children_missing_parents + pct_non_white +
            Binge.drinking.prevalence + pct_young_males + persons_per_m2 +
               periods + crime_rate_lag1 + (1 | county), data = acs_1_yearly_data)

# many insignificant predictors
summary(model_lag1)
plot(model_lag1)

qqnorm(resid(model_lag1))
qqline(resid(model_lag1), col = "red")
```

```{r acs_5_pre_modeling_comparisons}
### vars to calculate stats across for modeling
modeling_vars <- c(
  "crime_rate",
  "officers", "median_household_income_acs5", "pct_lessthan_5kincome", 
  "pct_highschool_or_greater", "pct_children_missing_parents", 
  "pct_non_white", "Binge.drinking.prevalence", "pct_young_males", 
  "persons_per_household", "persons_per_m2"
)

### t test across pre/post covid for all explanatory variables
pvals <- acs_5_yearly_data |>
  select(all_of(modeling_vars), post_covid) |>
  pivot_longer(-post_covid, names_to = "variable", values_to = "value") |>
  group_by(variable) |>
  summarise(
    ttest = list(t.test(value ~ post_covid, data = cur_data(), var.equal = FALSE)),
    .groups = "drop"
  ) |>
  mutate(p.value = map_dbl(ttest, ~ .x$p.value)) |>
  select(variable, p.value)

### Descriptive stats
summary_stats <- lapply(c(0,1), function(covid_indicatior){
  means <- acs_5_yearly_data |>
    filter(post_covid == covid_indicatior)|>
  summarise(across(all_of(modeling_vars), ~ mean(.x, na.rm = TRUE)))

  sds <- acs_5_yearly_data |>
    filter(post_covid == covid_indicatior)|>
    summarise(across(all_of(modeling_vars), ~ sd(.x, na.rm = TRUE)))
  
  bind_rows(list(mean = means, sd = sds), .id = "stat")|>
    pivot_longer(-stat, names_to = "variable", values_to = "value")|>
    pivot_wider(names_from = "stat")
  
})|> bind_rows(.id = "year")|> 
  mutate(year = ifelse(year == "1", "pre", "post"))|>
  pivot_wider(names_from = "year", values_from = c(mean, sd))

summary_stats <- left_join(summary_stats, pvals)|>
  arrange(p.value)

kable(summary_stats, format = "html",
             caption = "Signifigance of changes in Cesus variables")|>
kable_styling("striped")  


### correlation matrix
target <- "crime_rate"
crime_correlation <- lapply(setdiff(modeling_vars, target), function(var) {
  test <- cor.test(
    acs_5_yearly_data[[target]],
    acs_5_yearly_data[[var]],
    method = "pearson"
  )
  data.frame(
    variable = var,
    estimate = test$estimate[[1]],
    p.value = test$p.value
  )
}) |> bind_rows()|> arrange(p.value)

kable(crime_correlation, format = "html",
             caption = "Signifigance of correlation with crime rates")|>
kable_styling("striped")  

acs_5_yearly_data|>
  ggplot(aes(x = (crime_rate)))+
  geom_density()+
  geom_histogram(bins = 15)

acs_5_yearly_data|>
  ggplot(aes(x = sqrt(crime_rate)))+
  geom_density()+
  geom_histogram(bins = 15)

```

```{r acs5_modeling}
# need to arrange data before cum sum
acs_5_yearly_data <- acs_5_yearly_data|>arrange(post_covid) |>
  mutate(
    log_pct_non_white = log(pct_non_white),
    log_persons_per_m2 = log(persons_per_m2),
    log_officers = log(officers),
    log_crime_rate = log(officers)
  )

# removed "pct_children_missing_parents", "msp_main_counties", "Binge.drinking.prevalence", 
# "pct_young_males", "persons_per_household" due to insignfigance at the >.5 level
# "pct_lessthan_5kincome" removed due to -.7 correlation with median income and being a faulty measure over time

modeling_vars <- c("log_officers", "median_household_income_acs5", 
  "pct_highschool_or_greater", "log_pct_non_white", "log_persons_per_m2",
  "reservations", "top_cities"
)

formula <- reformulate(modeling_vars, response = "crime_rate")

# Fit models
pre_covid_model  <- lm(formula, data = acs_5_yearly_data |> filter(post_covid == 0))
post_covid_model <- lm(formula, data = acs_5_yearly_data |> filter(post_covid == 1))

full_formula <- reformulate(c(modeling_vars, "post_covid"), response = "crime_rate")
total_model  <- lm(full_formula, data = acs_5_yearly_data)

# Helper: get both normal and robust stats
model_tidy_with_robust <- function(model) {
  # Regular (classical OLS) tidy
  normal <- tidy(model)
  
  # Robust (HC3) tidy
  robust_vcov <- vcovHC(model, type = "HC3")
  robust <- coeftest(model, vcov. = robust_vcov) |> tidy()
  
  # Combine both
  normal |>
    select(term, estimate, std.error_normal = std.error) |>
    left_join(
      robust |> select(term, std.error_robust = std.error, p.value),
      by = "term"
    )
}

# Combine all models
combined <- bind_rows(
  model_tidy_with_robust(pre_covid_model)  |> mutate(Model = "Pre-COVID"),
  model_tidy_with_robust(post_covid_model) |> mutate(Model = "Post-COVID"),
  model_tidy_with_robust(total_model)      |> mutate(Model = "Full Model")
) |>
  mutate(across(c(std.error_normal, std.error_robust, p.value), ~ round(., 3))) |>
  select(Model, term, estimate, std.error_normal, std.error_robust, p.value)

# Compute row ranges for grouped rows
pre_rows  <- which(combined$Model == "Pre-COVID")
post_rows <- which(combined$Model == "Post-COVID")
full_rows <- which(combined$Model == "Full Model")

# Create the grouped kable table
kbl(combined, caption = "Regression Models with Classical & Robust Standard Errors (HC3)") |>
  kable_styling("striped", full_width = FALSE) |>
  group_rows("Pre-COVID",  min(pre_rows),  max(pre_rows)) |>
  group_rows("Post-COVID", min(post_rows), max(post_rows)) |>
  group_rows("Full Model", min(full_rows), max(full_rows))


# Compute model metrics
model_metrics <- tibble(
  Model    = c("Pre-COVID", "Post-COVID", "Full Model"),
  R2       = c(
    summary(pre_covid_model)$r.squared,
    summary(post_covid_model)$r.squared,
    summary(total_model)$r.squared
  ),
  Adj_R2   = c(
    summary(pre_covid_model)$adj.r.squared,
    summary(post_covid_model)$adj.r.squared,
    summary(total_model)$adj.r.squared
  ),
  RMSE     = c(
    sqrt(mean(residuals(pre_covid_model)^2)),
    sqrt(mean(residuals(post_covid_model)^2)),
    sqrt(mean(residuals(total_model)^2))
  )
) |>
  mutate(across(c(R2, Adj_R2, RMSE), ~ round(., 3)))

# Create the kable table
kbl(model_metrics, caption = "Model Performance Summary (R², Adjusted R², RMSE)") |>
  kable_styling("striped", full_width = FALSE)


# residuals vs fits
plot(pre_covid_model, 1)
plot(post_covid_model, 1)
plot(total_model, 1)


# Chow test using the 'post_covid' variable as the breakpoint
chow_test <- strucchange::sctest(total_model, type = "Chow", point = which(acs_5_yearly_data$post_covid == 1)[1])

print(chow_test)


# CUMSUM test
cumsum_process <- strucchange::efp(total_model, type = "OLS-CUSUM", data = acs_5_yearly_data)

# statistical test on the CUMSUM process
cumsum_test <- strucchange::sctest(cumsum_process)

print(cumsum_test)
plot(cumsum_process)

# rmse before/after
RMSE(pre_covid_model$residuals)
RMSE(post_covid_model$residuals)

# test for equal variances

# .5 bc test suggests sqrt transform 
bc <- MASS::boxcox(lm(full_formula, data = acs_5_yearly_data))
var.test(sqrt(acs_5_yearly_data$crime_rate) ~ acs_5_yearly_data$post_covid)
car::leveneTest(sqrt(acs_5_yearly_data$crime_rate) ~ as.factor(acs_5_yearly_data$post_covid))
```

```{r relationship_analysis}
target <- "crime_rate"

# Pivot the data into long format for faceting
facet_data <- acs_5_yearly_data |>
  pivot_longer(
    cols = all_of(setdiff(modeling_vars, target)),
    names_to = "variable",
    values_to = "value"
  )

# Make one big faceted plot
ggplot(facet_data, aes(x = value, y = .data[[target]])) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", color = "blue", se = TRUE) +
  facet_wrap(~ variable, scales = "free_x") +
  labs(
    x = "Predictor Value",
    y = "Crime Rate"
  ) +
  theme_bw()

# why does officers change in significance?
acs_5_yearly_data|>
  filter(post_covid == 0)|>
  ggplot(aes(x = officers, y = crime_rate))+
  geom_point()+
  geom_smooth(se = F, method = "lm")

acs_5_yearly_data|>
  filter(post_covid == 1)|>
  ggplot(aes(x = officers, y = crime_rate))+
  geom_point()+
  geom_smooth(se = F, method = "lm")
```

```{r differenced_data}

modeling_vars <- c("crime_rate", "log_officers", "median_household_income_acs5", "pct_lessthan_5kincome", 
  "pct_highschool_or_greater", "log_pct_non_white", "log_persons_per_m2"
)

acs_5_yearly_data_diff <- acs_5_yearly_data|>
  group_by(county)|>
  summarise(across(all_of(modeling_vars), ~ (.x[post_covid == 1] - .x[post_covid == 0]),
                   .names = "{.col}_diff"))

modeling_vars_diff <- paste0(modeling_vars[-1], "_diff")  # drop crime_rate, add _diff

model_diff <- lm(
  formula = as.formula(
    paste("crime_rate_diff ~", paste(modeling_vars_diff, collapse = " + "))
  ),
  data = acs_5_yearly_data_diff
)

diff_tbl <- tidy(model_diff) |>
  select(term, estimate, std.error, statistic, p.value) |>
  mutate(
    std.error = round(std.error, 3),
    p.value   = round(p.value, 3)
  ) |>
  mutate(Model = "Differenced Model") |>
  select(Model, term, estimate, std.error, p.value)

kbl(diff_tbl, caption = "Regression Model for Differences in Crime Rate") |>
  kable_styling("striped", full_width = FALSE) |>
  group_rows("Difference Model", 1, nrow(diff_tbl))
```
